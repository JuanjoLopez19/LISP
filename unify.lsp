(setf FALLO '"FALLO")

; Unify.lsp --> contains the main executation of the problem
(defun checker (E1 E2)
    (prog ()
        (terpri)
        (terpri)    
        (terpri)

        (princ "Condition Block start")
        (terpri)
        (princ "Check if E1 = E2")
        (when (equal E1 E2) (return NIL))
        (terpri)
        (terpri)
        (terpri)
        (princ "Check if E1 is a variable")
        (terpri)
        (terpri)
        (if (is_variable E1)
            (progn 
                (princ "E1 is a variable")
                (terpri)
                (terpri)
                (princ "Check if E1 is contained in E2")
                (terpri)
                (terpri)
                (if (is_contained E1 E2)
                    (return '"FALLO")
                    (return (list E2 E1))
                )
            )
            (progn
                (princ "E1 is not a variable")
                (terpri)
                (terpri)
                (princ "Check if E2 is a variable")
                (terpri)
                (terpri)
                (when (is_variable E2) (return (list E1 E2)))
            )
        )
        (return '"FALLO")
    )
)

(defun recursivity (E1 E2)
    (prog (F1 F2 G1 G2 Z1 Z2 T1 T2)
        (terpri)
        (princ "This is when neither of them are an atom")
        (terpri)
        ; First of each argument
        (setf F1 (first E1))
        (setf F2 (first E2))

        ; Rest of each argument
        (setf T1 (rest E1))
        (setf T2 (rest E2))
        (setf Z1 (unify F1 F2))
        (terpri)
        (terpri)
        (princ "Resultado de unificar los primeros items: ")
        (write z1)
        
        (when (equal Z1 FALLO) (return "FALLO"))
        (terpri)
        (terpri)

        (princ "Aplicar a la primera lista")
        (setf G1 (apply_items Z1 T1))
        (terpri)
        (princ "Resultado de aplicar 1: ")
        (write G1)
        (terpri)

        (princ "Aplicar a la segunda lista")
        (setf G2 (apply_items Z1 T2))
        (terpri)
        (princ "Resultado de aplicar 2: ")
        (write G2)
        (terpri)

        (princ "Unificar el resultado")
        (setf Z2 (unify G1 G2))
        (terpri)
        (write z2)
        (terpri)
        (when (equal Z2 FALLO) (return "FALLO"))
        (princ "Volver a iterar")
        (terpri)
        (terpri)
        (terpri)
        

        ;(return (compose Z1 Z2))
    )

)

(defun unify (E1 E2)
    (terpri)
    (terpri)
    (terpri)
    (princ "The first argument is: ")
    (write E1)
    (terpri)
    (princ "The second argument is: ")
    (write E2)

    (cond ((is_atom E1) (checker E1 E2))
          ((is_atom E2) (checker E2 E1))
          (T (recursivity E1 E2))
    )
)
